import numpy as np
import mujoco
from scipy.spatial import cKDTree  # <-- æ ¸å¿ƒç®—æ³•å‡çº§

class MeshDiggingSystem:
    def __init__(self, model, data, mesh_name, 
                 scene_body_name="voxel_target",  # ç¡®ä¿è¿™é‡Œè¿½è¸ªçš„æ˜¯å¸¦æ—‹è½¬çš„é‚£ä¸ªbody
                 voxel_xml_prefix="vx_", 
                 spacing=0.14, 
                 x_start=2.0):
        
        self.model = model
        self.data = data
        self.spacing = spacing
        self.box_size = spacing / 2
        self.wall_x_start = x_start
        self.scene_body_name = scene_body_name
        self.step_counter = 0
        
        # --- 0. è‡ªåŠ¨è®¡ç®—åœºæ™¯å˜æ¢çŸ©é˜µ ---
        self.scene_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, scene_body_name)
        if self.scene_body_id != -1:
            print(f"ğŸŒ é”å®šåœºæ™¯é”šç‚¹: '{scene_body_name}'")
            mujoco.mj_forward(model, data) 
            self.scene_pos = data.body(self.scene_body_id).xpos
            self.scene_rot = data.body(self.scene_body_id).xmat.reshape(3, 3)
            self.scene_rot_inv = self.scene_rot.T
        else:
            print(f"âš ï¸ è­¦å‘Š: æœªæ‰¾åˆ° '{scene_body_name}'ï¼Œå‡è®¾ä½äºåŸç‚¹ã€‚")
            self.scene_pos = np.array([0., 0., 0.])
            self.scene_rot_inv = np.eye(3)

        # --- 1. è·å– Mesh é¡¶ç‚¹å¹¶å»ºç«‹ KD-Tree ---
        print(f"ğŸ” æ­£åœ¨åŠ è½½æˆªå‰²å¤´ Mesh: '{mesh_name}'...")
        try:
            mesh_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_MESH, mesh_name)
            if mesh_id == -1:
                raise ValueError(f"âŒ æ‰¾ä¸åˆ° Mesh: '{mesh_name}'")
            
            vert_adr = model.mesh_vertadr[mesh_id]
            vert_num = model.mesh_vertnum[mesh_id]
            # è·å–æ‰€æœ‰é¡¶ç‚¹ (N, 3)
            self.mesh_verts = model.mesh_vert[vert_adr : vert_adr + vert_num * 3].reshape(-1, 3)
            
            # --- ğŸ›¡ï¸ è‡ªæ£€è¯Šæ–­ï¼šæ‰“å°å°ºå¯¸ ---
            min_v = np.min(self.mesh_verts, axis=0)
            max_v = np.max(self.mesh_verts, axis=0)
            dims = max_v - min_v
            print(f"ğŸ“ Mesh ç‰©ç†å°ºå¯¸ (XYZ): {dims[0]:.3f}m x {dims[1]:.3f}m x {dims[2]:.3f}m")
            if np.max(dims) > 5.0:
                print("âš ï¸ è­¦å‘Šï¼šMesh å°ºå¯¸çœ‹èµ·æ¥éå¸¸å·¨å¤§ï¼è¯·æ£€æŸ¥ STL å•ä½æ˜¯å¦é”™è¯¯ (æ¯”å¦‚æŠŠmmå½“æˆäº†m)ï¼Ÿ")

            # è®¡ç®—æœ€å¤§åŠå¾„ç”¨äºç²—ç­›
            self.max_radius = np.max(np.linalg.norm(self.mesh_verts, axis=1))

            # æ„å»º KD-Tree (æé€Ÿæœ€è¿‘é‚»æœç´¢)
            print("ğŸŒ² æ­£åœ¨æ„å»ºè¡¨é¢å‡ ä½•ç´¢å¼• (KD-Tree)...")
            self.kdtree = cKDTree(self.mesh_verts)
            print(f"âœ… åˆå§‹åŒ–å®Œæˆ! é¡¶ç‚¹æ•°: {len(self.mesh_verts)}")
            
        except Exception as e:
            print(f"âŒ åˆå§‹åŒ–å¤±è´¥: {e}")
            raise

        # --- 2. å»ºç«‹ä½“ç´ ç´¢å¼• ---
        self.voxel_index = {}
        self.active_voxels = set()
        print("ğŸ” æ­£åœ¨ç´¢å¼•ä½“ç´ ...")
        body_names = [mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_BODY, i) for i in range(model.nbody)]
        count = 0
        for i, name in enumerate(body_names):
            if name and name.startswith(voxel_xml_prefix):
                try:
                    parts = name.split('_')
                    k, i_idx, j = int(parts[1]), int(parts[2]), int(parts[3])
                    self.voxel_index[(k, i_idx, j)] = i
                    self.active_voxels.add((k, i_idx, j))
                    count += 1
                except: pass
        print(f"âœ… ç´¢å¼•å®Œæˆã€‚ä½“ç´ æ•°é‡: {count}")

    def world_to_local_grid(self, x, y, z):
        p_world = np.array([x, y, z])
        p_centered = p_world - self.scene_pos
        p_local = self.scene_rot_inv @ p_centered
        k = int(round((p_local[0] - self.wall_x_start - self.box_size) / self.spacing))
        i = int(round((p_local[2] - self.box_size) / self.spacing))
        j = int(round(p_local[1] / self.spacing))
        return k, i, j

    def perform_cutting(self, cutting_body_name, tolerance=0.02):
        """
        :param tolerance: æ¥è§¦å®¹å·® (ç±³)ã€‚é»˜è®¤ 0.02 (2cm)ã€‚
                          æ„æ€æ˜¯ï¼šåªè¦ä½“ç´ ä¸­å¿ƒè·ç¦» Mesh è¡¨é¢å°äº 2cmï¼Œå°±åˆ¤å®šä¸ºæ¥è§¦ã€‚
        """
        self.step_counter += 1
        reward = 0
        
        body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, cutting_body_name)
        if body_id == -1: return 0
        
        head_pos = self.data.body(body_id).xpos
        head_mat = self.data.body(body_id).xmat.reshape(3, 3)
        
        # 1. ã€ç²—ç­›ã€‘åŸºäºåŒ…å›´çƒ
        center_k, center_i, center_j = self.world_to_local_grid(*head_pos)
        search_range = int(np.ceil(self.max_radius / self.spacing)) + 1
        
        candidates = []
        candidate_keys = []
        
        for dk in range(-search_range, search_range + 1):
            for di in range(-search_range, search_range + 1):
                for dj in range(-search_range, search_range + 1):
                    key = (center_k + dk, center_i + di, center_j + dj)
                    if key in self.active_voxels:
                        vid = self.voxel_index[key]
                        v_pos = self.data.body(vid).xpos
                        candidates.append(v_pos)
                        candidate_keys.append(key)
        
        if not candidates:
            return 0
        
        candidates = np.array(candidates)
        
        # 2. ã€ç²¾ç­›ã€‘KD-Tree è´´è‚¤æ£€æµ‹ (Point Cloud Distance)
        # å°†ä½“ç´ åæ ‡è½¬æ¢åˆ°æˆªå‰²å¤´çš„å±€éƒ¨åæ ‡ç³»
        # Transformation: P_local = (P_world - T_body) @ R_body
        voxels_in_head_frame = (candidates - head_pos) @ head_mat 
        
        # æŸ¥è¯¢æœ€è¿‘é‚»è·ç¦» (Distance to nearest vertex)
        # k=1 è¡¨ç¤ºæ‰¾æœ€è¿‘çš„1ä¸ªç‚¹
        dists, _ = self.kdtree.query(voxels_in_head_frame, k=1)
        
        # 3. åˆ¤å®šï¼šå¦‚æœè·ç¦»å°äºå®¹å·®ï¼Œè¯´æ˜ç¢°åˆ°äº†
        # ä½¿ç”¨ KD-Tree åï¼Œå‡¹é™·éƒ¨åˆ†ï¼ˆæˆªé½¿ä¹‹é—´ï¼‰è·ç¦»ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥ä¸ä¼šè¯¯åˆ¤ï¼
        is_hit = dists <= tolerance
        
        indices_to_remove = np.where(is_hit)[0]
        
        for idx in indices_to_remove:
            key = candidate_keys[idx]
            body_id = self.voxel_index[key]
            
            geom_id = self.model.body_geomadr[body_id]
            if geom_id != -1:
                self.model.geom_size[geom_id] = [0, 0, 0]
                self.model.geom_rgba[geom_id] = [0, 0, 0, 0]
            
            self.active_voxels.remove(key)
            reward += 1
            print(f"ğŸ’¥ ç²‰ç¢ä½“ç´ ! (è·ç¦»è¡¨é¢ {dists[idx]*1000:.1f} mm)")
            
        return reward